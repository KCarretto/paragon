// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/kcarretto/paragon/ent/credential"
	"github.com/kcarretto/paragon/ent/event"
	"github.com/kcarretto/paragon/ent/file"
	"github.com/kcarretto/paragon/ent/job"
	"github.com/kcarretto/paragon/ent/link"
	"github.com/kcarretto/paragon/ent/predicate"
	"github.com/kcarretto/paragon/ent/service"
	"github.com/kcarretto/paragon/ent/tag"
	"github.com/kcarretto/paragon/ent/target"
	"github.com/kcarretto/paragon/ent/task"
	"github.com/kcarretto/paragon/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCredential = "Credential"
	TypeEvent      = "Event"
	TypeFile       = "File"
	TypeJob        = "Job"
	TypeLink       = "Link"
	TypeService    = "Service"
	TypeTag        = "Tag"
	TypeTarget     = "Target"
	TypeTask       = "Task"
	TypeUser       = "User"
)

// CredentialMutation represents an operation that mutates the Credential nodes in the graph.
type CredentialMutation struct {
	config
	op            Op
	typ           string
	id            *int
	principal     *string
	secret        *string
	kind          *credential.Kind
	fails         *int
	addfails      *int
	clearedFields map[string]struct{}
	target        *int
	clearedtarget bool
	done          bool
	oldValue      func(context.Context) (*Credential, error)
	predicates    []predicate.Credential
}

var _ ent.Mutation = (*CredentialMutation)(nil)

// credentialOption allows management of the mutation configuration using functional options.
type credentialOption func(*CredentialMutation)

// newCredentialMutation creates new mutation for the Credential entity.
func newCredentialMutation(c config, op Op, opts ...credentialOption) *CredentialMutation {
	m := &CredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialID sets the ID field of the mutation.
func withCredentialID(id int) credentialOption {
	return func(m *CredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *Credential
		)
		m.oldValue = func(ctx context.Context) (*Credential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredential sets the old Credential of the mutation.
func withCredential(node *Credential) credentialOption {
	return func(m *CredentialMutation) {
		m.oldValue = func(context.Context) (*Credential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CredentialMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrincipal sets the "principal" field.
func (m *CredentialMutation) SetPrincipal(s string) {
	m.principal = &s
}

// Principal returns the value of the "principal" field in the mutation.
func (m *CredentialMutation) Principal() (r string, exists bool) {
	v := m.principal
	if v == nil {
		return
	}
	return *v, true
}

// OldPrincipal returns the old "principal" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldPrincipal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrincipal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrincipal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrincipal: %w", err)
	}
	return oldValue.Principal, nil
}

// ResetPrincipal resets all changes to the "principal" field.
func (m *CredentialMutation) ResetPrincipal() {
	m.principal = nil
}

// SetSecret sets the "secret" field.
func (m *CredentialMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *CredentialMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *CredentialMutation) ResetSecret() {
	m.secret = nil
}

// SetKind sets the "kind" field.
func (m *CredentialMutation) SetKind(c credential.Kind) {
	m.kind = &c
}

// Kind returns the value of the "kind" field in the mutation.
func (m *CredentialMutation) Kind() (r credential.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldKind(ctx context.Context) (v credential.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *CredentialMutation) ResetKind() {
	m.kind = nil
}

// SetFails sets the "fails" field.
func (m *CredentialMutation) SetFails(i int) {
	m.fails = &i
	m.addfails = nil
}

// Fails returns the value of the "fails" field in the mutation.
func (m *CredentialMutation) Fails() (r int, exists bool) {
	v := m.fails
	if v == nil {
		return
	}
	return *v, true
}

// OldFails returns the old "fails" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldFails(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFails: %w", err)
	}
	return oldValue.Fails, nil
}

// AddFails adds i to the "fails" field.
func (m *CredentialMutation) AddFails(i int) {
	if m.addfails != nil {
		*m.addfails += i
	} else {
		m.addfails = &i
	}
}

// AddedFails returns the value that was added to the "fails" field in this mutation.
func (m *CredentialMutation) AddedFails() (r int, exists bool) {
	v := m.addfails
	if v == nil {
		return
	}
	return *v, true
}

// ResetFails resets all changes to the "fails" field.
func (m *CredentialMutation) ResetFails() {
	m.fails = nil
	m.addfails = nil
}

// SetTargetID sets the "target" edge to the Target entity by id.
func (m *CredentialMutation) SetTargetID(id int) {
	m.target = &id
}

// ClearTarget clears the "target" edge to the Target entity.
func (m *CredentialMutation) ClearTarget() {
	m.clearedtarget = true
}

// TargetCleared reports if the "target" edge to the Target entity was cleared.
func (m *CredentialMutation) TargetCleared() bool {
	return m.clearedtarget
}

// TargetID returns the "target" edge ID in the mutation.
func (m *CredentialMutation) TargetID() (id int, exists bool) {
	if m.target != nil {
		return *m.target, true
	}
	return
}

// TargetIDs returns the "target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetID instead. It exists only for internal usage by the builders.
func (m *CredentialMutation) TargetIDs() (ids []int) {
	if id := m.target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTarget resets all changes to the "target" edge.
func (m *CredentialMutation) ResetTarget() {
	m.target = nil
	m.clearedtarget = false
}

// Where appends a list predicates to the CredentialMutation builder.
func (m *CredentialMutation) Where(ps ...predicate.Credential) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CredentialMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Credential).
func (m *CredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.principal != nil {
		fields = append(fields, credential.FieldPrincipal)
	}
	if m.secret != nil {
		fields = append(fields, credential.FieldSecret)
	}
	if m.kind != nil {
		fields = append(fields, credential.FieldKind)
	}
	if m.fails != nil {
		fields = append(fields, credential.FieldFails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldPrincipal:
		return m.Principal()
	case credential.FieldSecret:
		return m.Secret()
	case credential.FieldKind:
		return m.Kind()
	case credential.FieldFails:
		return m.Fails()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credential.FieldPrincipal:
		return m.OldPrincipal(ctx)
	case credential.FieldSecret:
		return m.OldSecret(ctx)
	case credential.FieldKind:
		return m.OldKind(ctx)
	case credential.FieldFails:
		return m.OldFails(ctx)
	}
	return nil, fmt.Errorf("unknown Credential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credential.FieldPrincipal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrincipal(v)
		return nil
	case credential.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case credential.FieldKind:
		v, ok := value.(credential.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case credential.FieldFails:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFails(v)
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialMutation) AddedFields() []string {
	var fields []string
	if m.addfails != nil {
		fields = append(fields, credential.FieldFails)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldFails:
		return m.AddedFails()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case credential.FieldFails:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFails(v)
		return nil
	}
	return fmt.Errorf("unknown Credential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Credential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialMutation) ResetField(name string) error {
	switch name {
	case credential.FieldPrincipal:
		m.ResetPrincipal()
		return nil
	case credential.FieldSecret:
		m.ResetSecret()
		return nil
	case credential.FieldKind:
		m.ResetKind()
		return nil
	case credential.FieldFails:
		m.ResetFails()
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.target != nil {
		edges = append(edges, credential.EdgeTarget)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credential.EdgeTarget:
		if id := m.target; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtarget {
		edges = append(edges, credential.EdgeTarget)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case credential.EdgeTarget:
		return m.clearedtarget
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialMutation) ClearEdge(name string) error {
	switch name {
	case credential.EdgeTarget:
		m.ClearTarget()
		return nil
	}
	return fmt.Errorf("unknown Credential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialMutation) ResetEdge(name string) error {
	switch name {
	case credential.EdgeTarget:
		m.ResetTarget()
		return nil
	}
	return fmt.Errorf("unknown Credential edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_CreationTime     *time.Time
	_Kind             *event.Kind
	clearedFields     map[string]struct{}
	job               *int
	clearedjob        bool
	file              *int
	clearedfile       bool
	credential        *int
	clearedcredential bool
	link              *int
	clearedlink       bool
	tag               *int
	clearedtag        bool
	target            *int
	clearedtarget     bool
	task              *int
	clearedtask       bool
	user              *int
	cleareduser       bool
	event             *int
	clearedevent      bool
	service           *int
	clearedservice    bool
	likers            map[int]struct{}
	removedlikers     map[int]struct{}
	clearedlikers     bool
	owner             *int
	clearedowner      bool
	svcOwner          *int
	clearedsvcOwner   bool
	done              bool
	oldValue          func(context.Context) (*Event, error)
	predicates        []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreationTime sets the "CreationTime" field.
func (m *EventMutation) SetCreationTime(t time.Time) {
	m._CreationTime = &t
}

// CreationTime returns the value of the "CreationTime" field in the mutation.
func (m *EventMutation) CreationTime() (r time.Time, exists bool) {
	v := m._CreationTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationTime returns the old "CreationTime" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreationTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationTime: %w", err)
	}
	return oldValue.CreationTime, nil
}

// ResetCreationTime resets all changes to the "CreationTime" field.
func (m *EventMutation) ResetCreationTime() {
	m._CreationTime = nil
}

// SetKind sets the "Kind" field.
func (m *EventMutation) SetKind(e event.Kind) {
	m._Kind = &e
}

// Kind returns the value of the "Kind" field in the mutation.
func (m *EventMutation) Kind() (r event.Kind, exists bool) {
	v := m._Kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "Kind" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldKind(ctx context.Context) (v event.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "Kind" field.
func (m *EventMutation) ResetKind() {
	m._Kind = nil
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *EventMutation) SetJobID(id int) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *EventMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *EventMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *EventMutation) JobID() (id int, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *EventMutation) JobIDs() (ids []int) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *EventMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *EventMutation) SetFileID(id int) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *EventMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *EventMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *EventMutation) FileID() (id int, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *EventMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *EventMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// SetCredentialID sets the "credential" edge to the Credential entity by id.
func (m *EventMutation) SetCredentialID(id int) {
	m.credential = &id
}

// ClearCredential clears the "credential" edge to the Credential entity.
func (m *EventMutation) ClearCredential() {
	m.clearedcredential = true
}

// CredentialCleared reports if the "credential" edge to the Credential entity was cleared.
func (m *EventMutation) CredentialCleared() bool {
	return m.clearedcredential
}

// CredentialID returns the "credential" edge ID in the mutation.
func (m *EventMutation) CredentialID() (id int, exists bool) {
	if m.credential != nil {
		return *m.credential, true
	}
	return
}

// CredentialIDs returns the "credential" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CredentialID instead. It exists only for internal usage by the builders.
func (m *EventMutation) CredentialIDs() (ids []int) {
	if id := m.credential; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCredential resets all changes to the "credential" edge.
func (m *EventMutation) ResetCredential() {
	m.credential = nil
	m.clearedcredential = false
}

// SetLinkID sets the "link" edge to the Link entity by id.
func (m *EventMutation) SetLinkID(id int) {
	m.link = &id
}

// ClearLink clears the "link" edge to the Link entity.
func (m *EventMutation) ClearLink() {
	m.clearedlink = true
}

// LinkCleared reports if the "link" edge to the Link entity was cleared.
func (m *EventMutation) LinkCleared() bool {
	return m.clearedlink
}

// LinkID returns the "link" edge ID in the mutation.
func (m *EventMutation) LinkID() (id int, exists bool) {
	if m.link != nil {
		return *m.link, true
	}
	return
}

// LinkIDs returns the "link" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LinkID instead. It exists only for internal usage by the builders.
func (m *EventMutation) LinkIDs() (ids []int) {
	if id := m.link; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLink resets all changes to the "link" edge.
func (m *EventMutation) ResetLink() {
	m.link = nil
	m.clearedlink = false
}

// SetTagID sets the "tag" edge to the Tag entity by id.
func (m *EventMutation) SetTagID(id int) {
	m.tag = &id
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *EventMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *EventMutation) TagCleared() bool {
	return m.clearedtag
}

// TagID returns the "tag" edge ID in the mutation.
func (m *EventMutation) TagID() (id int, exists bool) {
	if m.tag != nil {
		return *m.tag, true
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *EventMutation) TagIDs() (ids []int) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *EventMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// SetTargetID sets the "target" edge to the Target entity by id.
func (m *EventMutation) SetTargetID(id int) {
	m.target = &id
}

// ClearTarget clears the "target" edge to the Target entity.
func (m *EventMutation) ClearTarget() {
	m.clearedtarget = true
}

// TargetCleared reports if the "target" edge to the Target entity was cleared.
func (m *EventMutation) TargetCleared() bool {
	return m.clearedtarget
}

// TargetID returns the "target" edge ID in the mutation.
func (m *EventMutation) TargetID() (id int, exists bool) {
	if m.target != nil {
		return *m.target, true
	}
	return
}

// TargetIDs returns the "target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetID instead. It exists only for internal usage by the builders.
func (m *EventMutation) TargetIDs() (ids []int) {
	if id := m.target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTarget resets all changes to the "target" edge.
func (m *EventMutation) ResetTarget() {
	m.target = nil
	m.clearedtarget = false
}

// SetTaskID sets the "task" edge to the Task entity by id.
func (m *EventMutation) SetTaskID(id int) {
	m.task = &id
}

// ClearTask clears the "task" edge to the Task entity.
func (m *EventMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *EventMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskID returns the "task" edge ID in the mutation.
func (m *EventMutation) TaskID() (id int, exists bool) {
	if m.task != nil {
		return *m.task, true
	}
	return
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *EventMutation) TaskIDs() (ids []int) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *EventMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *EventMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *EventMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EventMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *EventMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EventMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EventMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *EventMutation) SetEventID(id int) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *EventMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *EventMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *EventMutation) EventID() (id int, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *EventMutation) EventIDs() (ids []int) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *EventMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// SetServiceID sets the "service" edge to the Service entity by id.
func (m *EventMutation) SetServiceID(id int) {
	m.service = &id
}

// ClearService clears the "service" edge to the Service entity.
func (m *EventMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *EventMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the "service" edge ID in the mutation.
func (m *EventMutation) ServiceID() (id int, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *EventMutation) ServiceIDs() (ids []int) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *EventMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// AddLikerIDs adds the "likers" edge to the User entity by ids.
func (m *EventMutation) AddLikerIDs(ids ...int) {
	if m.likers == nil {
		m.likers = make(map[int]struct{})
	}
	for i := range ids {
		m.likers[ids[i]] = struct{}{}
	}
}

// ClearLikers clears the "likers" edge to the User entity.
func (m *EventMutation) ClearLikers() {
	m.clearedlikers = true
}

// LikersCleared reports if the "likers" edge to the User entity was cleared.
func (m *EventMutation) LikersCleared() bool {
	return m.clearedlikers
}

// RemoveLikerIDs removes the "likers" edge to the User entity by IDs.
func (m *EventMutation) RemoveLikerIDs(ids ...int) {
	if m.removedlikers == nil {
		m.removedlikers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.likers, ids[i])
		m.removedlikers[ids[i]] = struct{}{}
	}
}

// RemovedLikers returns the removed IDs of the "likers" edge to the User entity.
func (m *EventMutation) RemovedLikersIDs() (ids []int) {
	for id := range m.removedlikers {
		ids = append(ids, id)
	}
	return
}

// LikersIDs returns the "likers" edge IDs in the mutation.
func (m *EventMutation) LikersIDs() (ids []int) {
	for id := range m.likers {
		ids = append(ids, id)
	}
	return
}

// ResetLikers resets all changes to the "likers" edge.
func (m *EventMutation) ResetLikers() {
	m.likers = nil
	m.clearedlikers = false
	m.removedlikers = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *EventMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *EventMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *EventMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *EventMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *EventMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *EventMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetSvcOwnerID sets the "svcOwner" edge to the Service entity by id.
func (m *EventMutation) SetSvcOwnerID(id int) {
	m.svcOwner = &id
}

// ClearSvcOwner clears the "svcOwner" edge to the Service entity.
func (m *EventMutation) ClearSvcOwner() {
	m.clearedsvcOwner = true
}

// SvcOwnerCleared reports if the "svcOwner" edge to the Service entity was cleared.
func (m *EventMutation) SvcOwnerCleared() bool {
	return m.clearedsvcOwner
}

// SvcOwnerID returns the "svcOwner" edge ID in the mutation.
func (m *EventMutation) SvcOwnerID() (id int, exists bool) {
	if m.svcOwner != nil {
		return *m.svcOwner, true
	}
	return
}

// SvcOwnerIDs returns the "svcOwner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SvcOwnerID instead. It exists only for internal usage by the builders.
func (m *EventMutation) SvcOwnerIDs() (ids []int) {
	if id := m.svcOwner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSvcOwner resets all changes to the "svcOwner" edge.
func (m *EventMutation) ResetSvcOwner() {
	m.svcOwner = nil
	m.clearedsvcOwner = false
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._CreationTime != nil {
		fields = append(fields, event.FieldCreationTime)
	}
	if m._Kind != nil {
		fields = append(fields, event.FieldKind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreationTime:
		return m.CreationTime()
	case event.FieldKind:
		return m.Kind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreationTime:
		return m.OldCreationTime(ctx)
	case event.FieldKind:
		return m.OldKind(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationTime(v)
		return nil
	case event.FieldKind:
		v, ok := value.(event.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreationTime:
		m.ResetCreationTime()
		return nil
	case event.FieldKind:
		m.ResetKind()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.job != nil {
		edges = append(edges, event.EdgeJob)
	}
	if m.file != nil {
		edges = append(edges, event.EdgeFile)
	}
	if m.credential != nil {
		edges = append(edges, event.EdgeCredential)
	}
	if m.link != nil {
		edges = append(edges, event.EdgeLink)
	}
	if m.tag != nil {
		edges = append(edges, event.EdgeTag)
	}
	if m.target != nil {
		edges = append(edges, event.EdgeTarget)
	}
	if m.task != nil {
		edges = append(edges, event.EdgeTask)
	}
	if m.user != nil {
		edges = append(edges, event.EdgeUser)
	}
	if m.event != nil {
		edges = append(edges, event.EdgeEvent)
	}
	if m.service != nil {
		edges = append(edges, event.EdgeService)
	}
	if m.likers != nil {
		edges = append(edges, event.EdgeLikers)
	}
	if m.owner != nil {
		edges = append(edges, event.EdgeOwner)
	}
	if m.svcOwner != nil {
		edges = append(edges, event.EdgeSvcOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeCredential:
		if id := m.credential; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeLink:
		if id := m.link; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeTarget:
		if id := m.target; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeLikers:
		ids := make([]ent.Value, 0, len(m.likers))
		for id := range m.likers {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeSvcOwner:
		if id := m.svcOwner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedlikers != nil {
		edges = append(edges, event.EdgeLikers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeLikers:
		ids := make([]ent.Value, 0, len(m.removedlikers))
		for id := range m.removedlikers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedjob {
		edges = append(edges, event.EdgeJob)
	}
	if m.clearedfile {
		edges = append(edges, event.EdgeFile)
	}
	if m.clearedcredential {
		edges = append(edges, event.EdgeCredential)
	}
	if m.clearedlink {
		edges = append(edges, event.EdgeLink)
	}
	if m.clearedtag {
		edges = append(edges, event.EdgeTag)
	}
	if m.clearedtarget {
		edges = append(edges, event.EdgeTarget)
	}
	if m.clearedtask {
		edges = append(edges, event.EdgeTask)
	}
	if m.cleareduser {
		edges = append(edges, event.EdgeUser)
	}
	if m.clearedevent {
		edges = append(edges, event.EdgeEvent)
	}
	if m.clearedservice {
		edges = append(edges, event.EdgeService)
	}
	if m.clearedlikers {
		edges = append(edges, event.EdgeLikers)
	}
	if m.clearedowner {
		edges = append(edges, event.EdgeOwner)
	}
	if m.clearedsvcOwner {
		edges = append(edges, event.EdgeSvcOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeJob:
		return m.clearedjob
	case event.EdgeFile:
		return m.clearedfile
	case event.EdgeCredential:
		return m.clearedcredential
	case event.EdgeLink:
		return m.clearedlink
	case event.EdgeTag:
		return m.clearedtag
	case event.EdgeTarget:
		return m.clearedtarget
	case event.EdgeTask:
		return m.clearedtask
	case event.EdgeUser:
		return m.cleareduser
	case event.EdgeEvent:
		return m.clearedevent
	case event.EdgeService:
		return m.clearedservice
	case event.EdgeLikers:
		return m.clearedlikers
	case event.EdgeOwner:
		return m.clearedowner
	case event.EdgeSvcOwner:
		return m.clearedsvcOwner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeJob:
		m.ClearJob()
		return nil
	case event.EdgeFile:
		m.ClearFile()
		return nil
	case event.EdgeCredential:
		m.ClearCredential()
		return nil
	case event.EdgeLink:
		m.ClearLink()
		return nil
	case event.EdgeTag:
		m.ClearTag()
		return nil
	case event.EdgeTarget:
		m.ClearTarget()
		return nil
	case event.EdgeTask:
		m.ClearTask()
		return nil
	case event.EdgeUser:
		m.ClearUser()
		return nil
	case event.EdgeEvent:
		m.ClearEvent()
		return nil
	case event.EdgeService:
		m.ClearService()
		return nil
	case event.EdgeOwner:
		m.ClearOwner()
		return nil
	case event.EdgeSvcOwner:
		m.ClearSvcOwner()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeJob:
		m.ResetJob()
		return nil
	case event.EdgeFile:
		m.ResetFile()
		return nil
	case event.EdgeCredential:
		m.ResetCredential()
		return nil
	case event.EdgeLink:
		m.ResetLink()
		return nil
	case event.EdgeTag:
		m.ResetTag()
		return nil
	case event.EdgeTarget:
		m.ResetTarget()
		return nil
	case event.EdgeTask:
		m.ResetTask()
		return nil
	case event.EdgeUser:
		m.ResetUser()
		return nil
	case event.EdgeEvent:
		m.ResetEvent()
		return nil
	case event.EdgeService:
		m.ResetService()
		return nil
	case event.EdgeLikers:
		m.ResetLikers()
		return nil
	case event.EdgeOwner:
		m.ResetOwner()
		return nil
	case event.EdgeSvcOwner:
		m.ResetSvcOwner()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Name             *string
	_CreationTime     *time.Time
	_LastModifiedTime *time.Time
	_Size             *int
	add_Size          *int
	_Content          *[]byte
	_Hash             *string
	_ContentType      *string
	clearedFields     map[string]struct{}
	links             map[int]struct{}
	removedlinks      map[int]struct{}
	clearedlinks      bool
	done              bool
	oldValue          func(context.Context) (*File, error)
	predicates        []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *FileMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *FileMutation) ResetName() {
	m._Name = nil
}

// SetCreationTime sets the "CreationTime" field.
func (m *FileMutation) SetCreationTime(t time.Time) {
	m._CreationTime = &t
}

// CreationTime returns the value of the "CreationTime" field in the mutation.
func (m *FileMutation) CreationTime() (r time.Time, exists bool) {
	v := m._CreationTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationTime returns the old "CreationTime" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreationTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationTime: %w", err)
	}
	return oldValue.CreationTime, nil
}

// ResetCreationTime resets all changes to the "CreationTime" field.
func (m *FileMutation) ResetCreationTime() {
	m._CreationTime = nil
}

// SetLastModifiedTime sets the "LastModifiedTime" field.
func (m *FileMutation) SetLastModifiedTime(t time.Time) {
	m._LastModifiedTime = &t
}

// LastModifiedTime returns the value of the "LastModifiedTime" field in the mutation.
func (m *FileMutation) LastModifiedTime() (r time.Time, exists bool) {
	v := m._LastModifiedTime
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedTime returns the old "LastModifiedTime" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldLastModifiedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedTime: %w", err)
	}
	return oldValue.LastModifiedTime, nil
}

// ResetLastModifiedTime resets all changes to the "LastModifiedTime" field.
func (m *FileMutation) ResetLastModifiedTime() {
	m._LastModifiedTime = nil
}

// SetSize sets the "Size" field.
func (m *FileMutation) SetSize(i int) {
	m._Size = &i
	m.add_Size = nil
}

// Size returns the value of the "Size" field in the mutation.
func (m *FileMutation) Size() (r int, exists bool) {
	v := m._Size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "Size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "Size" field.
func (m *FileMutation) AddSize(i int) {
	if m.add_Size != nil {
		*m.add_Size += i
	} else {
		m.add_Size = &i
	}
}

// AddedSize returns the value that was added to the "Size" field in this mutation.
func (m *FileMutation) AddedSize() (r int, exists bool) {
	v := m.add_Size
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "Size" field.
func (m *FileMutation) ResetSize() {
	m._Size = nil
	m.add_Size = nil
}

// SetContent sets the "Content" field.
func (m *FileMutation) SetContent(b []byte) {
	m._Content = &b
}

// Content returns the value of the "Content" field in the mutation.
func (m *FileMutation) Content() (r []byte, exists bool) {
	v := m._Content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "Content" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldContent(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "Content" field.
func (m *FileMutation) ResetContent() {
	m._Content = nil
}

// SetHash sets the "Hash" field.
func (m *FileMutation) SetHash(s string) {
	m._Hash = &s
}

// Hash returns the value of the "Hash" field in the mutation.
func (m *FileMutation) Hash() (r string, exists bool) {
	v := m._Hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "Hash" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "Hash" field.
func (m *FileMutation) ResetHash() {
	m._Hash = nil
}

// SetContentType sets the "ContentType" field.
func (m *FileMutation) SetContentType(s string) {
	m._ContentType = &s
}

// ContentType returns the value of the "ContentType" field in the mutation.
func (m *FileMutation) ContentType() (r string, exists bool) {
	v := m._ContentType
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old "ContentType" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldContentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// ResetContentType resets all changes to the "ContentType" field.
func (m *FileMutation) ResetContentType() {
	m._ContentType = nil
}

// AddLinkIDs adds the "links" edge to the Link entity by ids.
func (m *FileMutation) AddLinkIDs(ids ...int) {
	if m.links == nil {
		m.links = make(map[int]struct{})
	}
	for i := range ids {
		m.links[ids[i]] = struct{}{}
	}
}

// ClearLinks clears the "links" edge to the Link entity.
func (m *FileMutation) ClearLinks() {
	m.clearedlinks = true
}

// LinksCleared reports if the "links" edge to the Link entity was cleared.
func (m *FileMutation) LinksCleared() bool {
	return m.clearedlinks
}

// RemoveLinkIDs removes the "links" edge to the Link entity by IDs.
func (m *FileMutation) RemoveLinkIDs(ids ...int) {
	if m.removedlinks == nil {
		m.removedlinks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.links, ids[i])
		m.removedlinks[ids[i]] = struct{}{}
	}
}

// RemovedLinks returns the removed IDs of the "links" edge to the Link entity.
func (m *FileMutation) RemovedLinksIDs() (ids []int) {
	for id := range m.removedlinks {
		ids = append(ids, id)
	}
	return
}

// LinksIDs returns the "links" edge IDs in the mutation.
func (m *FileMutation) LinksIDs() (ids []int) {
	for id := range m.links {
		ids = append(ids, id)
	}
	return
}

// ResetLinks resets all changes to the "links" edge.
func (m *FileMutation) ResetLinks() {
	m.links = nil
	m.clearedlinks = false
	m.removedlinks = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._Name != nil {
		fields = append(fields, file.FieldName)
	}
	if m._CreationTime != nil {
		fields = append(fields, file.FieldCreationTime)
	}
	if m._LastModifiedTime != nil {
		fields = append(fields, file.FieldLastModifiedTime)
	}
	if m._Size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m._Content != nil {
		fields = append(fields, file.FieldContent)
	}
	if m._Hash != nil {
		fields = append(fields, file.FieldHash)
	}
	if m._ContentType != nil {
		fields = append(fields, file.FieldContentType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldName:
		return m.Name()
	case file.FieldCreationTime:
		return m.CreationTime()
	case file.FieldLastModifiedTime:
		return m.LastModifiedTime()
	case file.FieldSize:
		return m.Size()
	case file.FieldContent:
		return m.Content()
	case file.FieldHash:
		return m.Hash()
	case file.FieldContentType:
		return m.ContentType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldCreationTime:
		return m.OldCreationTime(ctx)
	case file.FieldLastModifiedTime:
		return m.OldLastModifiedTime(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldContent:
		return m.OldContent(ctx)
	case file.FieldHash:
		return m.OldHash(ctx)
	case file.FieldContentType:
		return m.OldContentType(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldCreationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationTime(v)
		return nil
	case file.FieldLastModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedTime(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldContent:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case file.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case file.FieldContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.add_Size != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldCreationTime:
		m.ResetCreationTime()
		return nil
	case file.FieldLastModifiedTime:
		m.ResetLastModifiedTime()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldContent:
		m.ResetContent()
		return nil
	case file.FieldHash:
		m.ResetHash()
		return nil
	case file.FieldContentType:
		m.ResetContentType()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.links != nil {
		edges = append(edges, file.EdgeLinks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.links))
		for id := range m.links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlinks != nil {
		edges = append(edges, file.EdgeLinks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.removedlinks))
		for id := range m.removedlinks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlinks {
		edges = append(edges, file.EdgeLinks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeLinks:
		return m.clearedlinks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeLinks:
		m.ResetLinks()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// JobMutation represents an operation that mutates the Job nodes in the graph.
type JobMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_CreationTime *time.Time
	_Content      *string
	_Staged       *bool
	clearedFields map[string]struct{}
	tasks         map[int]struct{}
	removedtasks  map[int]struct{}
	clearedtasks  bool
	tags          map[int]struct{}
	removedtags   map[int]struct{}
	clearedtags   bool
	prev          *int
	clearedprev   bool
	next          *int
	clearednext   bool
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Job, error)
	predicates    []predicate.Job
}

var _ ent.Mutation = (*JobMutation)(nil)

// jobOption allows management of the mutation configuration using functional options.
type jobOption func(*JobMutation)

// newJobMutation creates new mutation for the Job entity.
func newJobMutation(c config, op Op, opts ...jobOption) *JobMutation {
	m := &JobMutation{
		config:        c,
		op:            op,
		typ:           TypeJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobID sets the ID field of the mutation.
func withJobID(id int) jobOption {
	return func(m *JobMutation) {
		var (
			err   error
			once  sync.Once
			value *Job
		)
		m.oldValue = func(ctx context.Context) (*Job, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Job.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJob sets the old Job of the mutation.
func withJob(node *Job) jobOption {
	return func(m *JobMutation) {
		m.oldValue = func(context.Context) (*Job, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Job.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *JobMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *JobMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *JobMutation) ResetName() {
	m._Name = nil
}

// SetCreationTime sets the "CreationTime" field.
func (m *JobMutation) SetCreationTime(t time.Time) {
	m._CreationTime = &t
}

// CreationTime returns the value of the "CreationTime" field in the mutation.
func (m *JobMutation) CreationTime() (r time.Time, exists bool) {
	v := m._CreationTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationTime returns the old "CreationTime" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCreationTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationTime: %w", err)
	}
	return oldValue.CreationTime, nil
}

// ResetCreationTime resets all changes to the "CreationTime" field.
func (m *JobMutation) ResetCreationTime() {
	m._CreationTime = nil
}

// SetContent sets the "Content" field.
func (m *JobMutation) SetContent(s string) {
	m._Content = &s
}

// Content returns the value of the "Content" field in the mutation.
func (m *JobMutation) Content() (r string, exists bool) {
	v := m._Content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "Content" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "Content" field.
func (m *JobMutation) ResetContent() {
	m._Content = nil
}

// SetStaged sets the "Staged" field.
func (m *JobMutation) SetStaged(b bool) {
	m._Staged = &b
}

// Staged returns the value of the "Staged" field in the mutation.
func (m *JobMutation) Staged() (r bool, exists bool) {
	v := m._Staged
	if v == nil {
		return
	}
	return *v, true
}

// OldStaged returns the old "Staged" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldStaged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStaged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStaged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaged: %w", err)
	}
	return oldValue.Staged, nil
}

// ResetStaged resets all changes to the "Staged" field.
func (m *JobMutation) ResetStaged() {
	m._Staged = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *JobMutation) AddTaskIDs(ids ...int) {
	if m.tasks == nil {
		m.tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *JobMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *JobMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *JobMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *JobMutation) RemovedTasksIDs() (ids []int) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *JobMutation) TasksIDs() (ids []int) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *JobMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *JobMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *JobMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *JobMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *JobMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *JobMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *JobMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *JobMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// SetPrevID sets the "prev" edge to the Job entity by id.
func (m *JobMutation) SetPrevID(id int) {
	m.prev = &id
}

// ClearPrev clears the "prev" edge to the Job entity.
func (m *JobMutation) ClearPrev() {
	m.clearedprev = true
}

// PrevCleared reports if the "prev" edge to the Job entity was cleared.
func (m *JobMutation) PrevCleared() bool {
	return m.clearedprev
}

// PrevID returns the "prev" edge ID in the mutation.
func (m *JobMutation) PrevID() (id int, exists bool) {
	if m.prev != nil {
		return *m.prev, true
	}
	return
}

// PrevIDs returns the "prev" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrevID instead. It exists only for internal usage by the builders.
func (m *JobMutation) PrevIDs() (ids []int) {
	if id := m.prev; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrev resets all changes to the "prev" edge.
func (m *JobMutation) ResetPrev() {
	m.prev = nil
	m.clearedprev = false
}

// SetNextID sets the "next" edge to the Job entity by id.
func (m *JobMutation) SetNextID(id int) {
	m.next = &id
}

// ClearNext clears the "next" edge to the Job entity.
func (m *JobMutation) ClearNext() {
	m.clearednext = true
}

// NextCleared reports if the "next" edge to the Job entity was cleared.
func (m *JobMutation) NextCleared() bool {
	return m.clearednext
}

// NextID returns the "next" edge ID in the mutation.
func (m *JobMutation) NextID() (id int, exists bool) {
	if m.next != nil {
		return *m.next, true
	}
	return
}

// NextIDs returns the "next" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NextID instead. It exists only for internal usage by the builders.
func (m *JobMutation) NextIDs() (ids []int) {
	if id := m.next; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNext resets all changes to the "next" edge.
func (m *JobMutation) ResetNext() {
	m.next = nil
	m.clearednext = false
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *JobMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *JobMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *JobMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *JobMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *JobMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *JobMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the JobMutation builder.
func (m *JobMutation) Where(ps ...predicate.Job) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *JobMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Job).
func (m *JobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Name != nil {
		fields = append(fields, job.FieldName)
	}
	if m._CreationTime != nil {
		fields = append(fields, job.FieldCreationTime)
	}
	if m._Content != nil {
		fields = append(fields, job.FieldContent)
	}
	if m._Staged != nil {
		fields = append(fields, job.FieldStaged)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case job.FieldName:
		return m.Name()
	case job.FieldCreationTime:
		return m.CreationTime()
	case job.FieldContent:
		return m.Content()
	case job.FieldStaged:
		return m.Staged()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case job.FieldName:
		return m.OldName(ctx)
	case job.FieldCreationTime:
		return m.OldCreationTime(ctx)
	case job.FieldContent:
		return m.OldContent(ctx)
	case job.FieldStaged:
		return m.OldStaged(ctx)
	}
	return nil, fmt.Errorf("unknown Job field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case job.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case job.FieldCreationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationTime(v)
		return nil
	case job.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case job.FieldStaged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaged(v)
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Job numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Job nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobMutation) ResetField(name string) error {
	switch name {
	case job.FieldName:
		m.ResetName()
		return nil
	case job.FieldCreationTime:
		m.ResetCreationTime()
		return nil
	case job.FieldContent:
		m.ResetContent()
		return nil
	case job.FieldStaged:
		m.ResetStaged()
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tasks != nil {
		edges = append(edges, job.EdgeTasks)
	}
	if m.tags != nil {
		edges = append(edges, job.EdgeTags)
	}
	if m.prev != nil {
		edges = append(edges, job.EdgePrev)
	}
	if m.next != nil {
		edges = append(edges, job.EdgeNext)
	}
	if m.owner != nil {
		edges = append(edges, job.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case job.EdgePrev:
		if id := m.prev; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeNext:
		if id := m.next; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtasks != nil {
		edges = append(edges, job.EdgeTasks)
	}
	if m.removedtags != nil {
		edges = append(edges, job.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtasks {
		edges = append(edges, job.EdgeTasks)
	}
	if m.clearedtags {
		edges = append(edges, job.EdgeTags)
	}
	if m.clearedprev {
		edges = append(edges, job.EdgePrev)
	}
	if m.clearednext {
		edges = append(edges, job.EdgeNext)
	}
	if m.clearedowner {
		edges = append(edges, job.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobMutation) EdgeCleared(name string) bool {
	switch name {
	case job.EdgeTasks:
		return m.clearedtasks
	case job.EdgeTags:
		return m.clearedtags
	case job.EdgePrev:
		return m.clearedprev
	case job.EdgeNext:
		return m.clearednext
	case job.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobMutation) ClearEdge(name string) error {
	switch name {
	case job.EdgePrev:
		m.ClearPrev()
		return nil
	case job.EdgeNext:
		m.ClearNext()
		return nil
	case job.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Job unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobMutation) ResetEdge(name string) error {
	switch name {
	case job.EdgeTasks:
		m.ResetTasks()
		return nil
	case job.EdgeTags:
		m.ResetTags()
		return nil
	case job.EdgePrev:
		m.ResetPrev()
		return nil
	case job.EdgeNext:
		m.ResetNext()
		return nil
	case job.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Job edge %s", name)
}

// LinkMutation represents an operation that mutates the Link nodes in the graph.
type LinkMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_Alias          *string
	_ExpirationTime *time.Time
	_Clicks         *int
	add_Clicks      *int
	clearedFields   map[string]struct{}
	file            *int
	clearedfile     bool
	done            bool
	oldValue        func(context.Context) (*Link, error)
	predicates      []predicate.Link
}

var _ ent.Mutation = (*LinkMutation)(nil)

// linkOption allows management of the mutation configuration using functional options.
type linkOption func(*LinkMutation)

// newLinkMutation creates new mutation for the Link entity.
func newLinkMutation(c config, op Op, opts ...linkOption) *LinkMutation {
	m := &LinkMutation{
		config:        c,
		op:            op,
		typ:           TypeLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLinkID sets the ID field of the mutation.
func withLinkID(id int) linkOption {
	return func(m *LinkMutation) {
		var (
			err   error
			once  sync.Once
			value *Link
		)
		m.oldValue = func(ctx context.Context) (*Link, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Link.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLink sets the old Link of the mutation.
func withLink(node *Link) linkOption {
	return func(m *LinkMutation) {
		m.oldValue = func(context.Context) (*Link, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Link.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlias sets the "Alias" field.
func (m *LinkMutation) SetAlias(s string) {
	m._Alias = &s
}

// Alias returns the value of the "Alias" field in the mutation.
func (m *LinkMutation) Alias() (r string, exists bool) {
	v := m._Alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "Alias" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "Alias" field.
func (m *LinkMutation) ResetAlias() {
	m._Alias = nil
}

// SetExpirationTime sets the "ExpirationTime" field.
func (m *LinkMutation) SetExpirationTime(t time.Time) {
	m._ExpirationTime = &t
}

// ExpirationTime returns the value of the "ExpirationTime" field in the mutation.
func (m *LinkMutation) ExpirationTime() (r time.Time, exists bool) {
	v := m._ExpirationTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationTime returns the old "ExpirationTime" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldExpirationTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationTime: %w", err)
	}
	return oldValue.ExpirationTime, nil
}

// ClearExpirationTime clears the value of the "ExpirationTime" field.
func (m *LinkMutation) ClearExpirationTime() {
	m._ExpirationTime = nil
	m.clearedFields[link.FieldExpirationTime] = struct{}{}
}

// ExpirationTimeCleared returns if the "ExpirationTime" field was cleared in this mutation.
func (m *LinkMutation) ExpirationTimeCleared() bool {
	_, ok := m.clearedFields[link.FieldExpirationTime]
	return ok
}

// ResetExpirationTime resets all changes to the "ExpirationTime" field.
func (m *LinkMutation) ResetExpirationTime() {
	m._ExpirationTime = nil
	delete(m.clearedFields, link.FieldExpirationTime)
}

// SetClicks sets the "Clicks" field.
func (m *LinkMutation) SetClicks(i int) {
	m._Clicks = &i
	m.add_Clicks = nil
}

// Clicks returns the value of the "Clicks" field in the mutation.
func (m *LinkMutation) Clicks() (r int, exists bool) {
	v := m._Clicks
	if v == nil {
		return
	}
	return *v, true
}

// OldClicks returns the old "Clicks" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldClicks(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClicks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClicks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClicks: %w", err)
	}
	return oldValue.Clicks, nil
}

// AddClicks adds i to the "Clicks" field.
func (m *LinkMutation) AddClicks(i int) {
	if m.add_Clicks != nil {
		*m.add_Clicks += i
	} else {
		m.add_Clicks = &i
	}
}

// AddedClicks returns the value that was added to the "Clicks" field in this mutation.
func (m *LinkMutation) AddedClicks() (r int, exists bool) {
	v := m.add_Clicks
	if v == nil {
		return
	}
	return *v, true
}

// ResetClicks resets all changes to the "Clicks" field.
func (m *LinkMutation) ResetClicks() {
	m._Clicks = nil
	m.add_Clicks = nil
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *LinkMutation) SetFileID(id int) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *LinkMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *LinkMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *LinkMutation) FileID() (id int, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *LinkMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *LinkMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the LinkMutation builder.
func (m *LinkMutation) Where(ps ...predicate.Link) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LinkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Link).
func (m *LinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LinkMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Alias != nil {
		fields = append(fields, link.FieldAlias)
	}
	if m._ExpirationTime != nil {
		fields = append(fields, link.FieldExpirationTime)
	}
	if m._Clicks != nil {
		fields = append(fields, link.FieldClicks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case link.FieldAlias:
		return m.Alias()
	case link.FieldExpirationTime:
		return m.ExpirationTime()
	case link.FieldClicks:
		return m.Clicks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case link.FieldAlias:
		return m.OldAlias(ctx)
	case link.FieldExpirationTime:
		return m.OldExpirationTime(ctx)
	case link.FieldClicks:
		return m.OldClicks(ctx)
	}
	return nil, fmt.Errorf("unknown Link field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case link.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	case link.FieldExpirationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationTime(v)
		return nil
	case link.FieldClicks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClicks(v)
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LinkMutation) AddedFields() []string {
	var fields []string
	if m.add_Clicks != nil {
		fields = append(fields, link.FieldClicks)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case link.FieldClicks:
		return m.AddedClicks()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case link.FieldClicks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClicks(v)
		return nil
	}
	return fmt.Errorf("unknown Link numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(link.FieldExpirationTime) {
		fields = append(fields, link.FieldExpirationTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LinkMutation) ClearField(name string) error {
	switch name {
	case link.FieldExpirationTime:
		m.ClearExpirationTime()
		return nil
	}
	return fmt.Errorf("unknown Link nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LinkMutation) ResetField(name string) error {
	switch name {
	case link.FieldAlias:
		m.ResetAlias()
		return nil
	case link.FieldExpirationTime:
		m.ResetExpirationTime()
		return nil
	case link.FieldClicks:
		m.ResetClicks()
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file != nil {
		edges = append(edges, link.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case link.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LinkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile {
		edges = append(edges, link.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LinkMutation) EdgeCleared(name string) bool {
	switch name {
	case link.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LinkMutation) ClearEdge(name string) error {
	switch name {
	case link.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown Link unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LinkMutation) ResetEdge(name string) error {
	switch name {
	case link.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown Link edge %s", name)
}

// ServiceMutation represents an operation that mutates the Service nodes in the graph.
type ServiceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_PubKey       *string
	_Config       *string
	_IsActivated  *bool
	clearedFields map[string]struct{}
	tag           *int
	clearedtag    bool
	events        map[int]struct{}
	removedevents map[int]struct{}
	clearedevents bool
	done          bool
	oldValue      func(context.Context) (*Service, error)
	predicates    []predicate.Service
}

var _ ent.Mutation = (*ServiceMutation)(nil)

// serviceOption allows management of the mutation configuration using functional options.
type serviceOption func(*ServiceMutation)

// newServiceMutation creates new mutation for the Service entity.
func newServiceMutation(c config, op Op, opts ...serviceOption) *ServiceMutation {
	m := &ServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceID sets the ID field of the mutation.
func withServiceID(id int) serviceOption {
	return func(m *ServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Service
		)
		m.oldValue = func(ctx context.Context) (*Service, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Service.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withService sets the old Service of the mutation.
func withService(node *Service) serviceOption {
	return func(m *ServiceMutation) {
		m.oldValue = func(context.Context) (*Service, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Service.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *ServiceMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *ServiceMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *ServiceMutation) ResetName() {
	m._Name = nil
}

// SetPubKey sets the "PubKey" field.
func (m *ServiceMutation) SetPubKey(s string) {
	m._PubKey = &s
}

// PubKey returns the value of the "PubKey" field in the mutation.
func (m *ServiceMutation) PubKey() (r string, exists bool) {
	v := m._PubKey
	if v == nil {
		return
	}
	return *v, true
}

// OldPubKey returns the old "PubKey" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldPubKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPubKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPubKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPubKey: %w", err)
	}
	return oldValue.PubKey, nil
}

// ResetPubKey resets all changes to the "PubKey" field.
func (m *ServiceMutation) ResetPubKey() {
	m._PubKey = nil
}

// SetConfig sets the "Config" field.
func (m *ServiceMutation) SetConfig(s string) {
	m._Config = &s
}

// Config returns the value of the "Config" field in the mutation.
func (m *ServiceMutation) Config() (r string, exists bool) {
	v := m._Config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "Config" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "Config" field.
func (m *ServiceMutation) ResetConfig() {
	m._Config = nil
}

// SetIsActivated sets the "IsActivated" field.
func (m *ServiceMutation) SetIsActivated(b bool) {
	m._IsActivated = &b
}

// IsActivated returns the value of the "IsActivated" field in the mutation.
func (m *ServiceMutation) IsActivated() (r bool, exists bool) {
	v := m._IsActivated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActivated returns the old "IsActivated" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldIsActivated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActivated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActivated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActivated: %w", err)
	}
	return oldValue.IsActivated, nil
}

// ResetIsActivated resets all changes to the "IsActivated" field.
func (m *ServiceMutation) ResetIsActivated() {
	m._IsActivated = nil
}

// SetTagID sets the "tag" edge to the Tag entity by id.
func (m *ServiceMutation) SetTagID(id int) {
	m.tag = &id
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *ServiceMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *ServiceMutation) TagCleared() bool {
	return m.clearedtag
}

// TagID returns the "tag" edge ID in the mutation.
func (m *ServiceMutation) TagID() (id int, exists bool) {
	if m.tag != nil {
		return *m.tag, true
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) TagIDs() (ids []int) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *ServiceMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *ServiceMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *ServiceMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *ServiceMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *ServiceMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *ServiceMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *ServiceMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *ServiceMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the ServiceMutation builder.
func (m *ServiceMutation) Where(ps ...predicate.Service) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ServiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Service).
func (m *ServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Name != nil {
		fields = append(fields, service.FieldName)
	}
	if m._PubKey != nil {
		fields = append(fields, service.FieldPubKey)
	}
	if m._Config != nil {
		fields = append(fields, service.FieldConfig)
	}
	if m._IsActivated != nil {
		fields = append(fields, service.FieldIsActivated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case service.FieldName:
		return m.Name()
	case service.FieldPubKey:
		return m.PubKey()
	case service.FieldConfig:
		return m.Config()
	case service.FieldIsActivated:
		return m.IsActivated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case service.FieldName:
		return m.OldName(ctx)
	case service.FieldPubKey:
		return m.OldPubKey(ctx)
	case service.FieldConfig:
		return m.OldConfig(ctx)
	case service.FieldIsActivated:
		return m.OldIsActivated(ctx)
	}
	return nil, fmt.Errorf("unknown Service field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case service.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case service.FieldPubKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPubKey(v)
		return nil
	case service.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case service.FieldIsActivated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActivated(v)
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Service numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Service nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceMutation) ResetField(name string) error {
	switch name {
	case service.FieldName:
		m.ResetName()
		return nil
	case service.FieldPubKey:
		m.ResetPubKey()
		return nil
	case service.FieldConfig:
		m.ResetConfig()
		return nil
	case service.FieldIsActivated:
		m.ResetIsActivated()
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tag != nil {
		edges = append(edges, service.EdgeTag)
	}
	if m.events != nil {
		edges = append(edges, service.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedevents != nil {
		edges = append(edges, service.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtag {
		edges = append(edges, service.EdgeTag)
	}
	if m.clearedevents {
		edges = append(edges, service.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case service.EdgeTag:
		return m.clearedtag
	case service.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceMutation) ClearEdge(name string) error {
	switch name {
	case service.EdgeTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown Service unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceMutation) ResetEdge(name string) error {
	switch name {
	case service.EdgeTag:
		m.ResetTag()
		return nil
	case service.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Service edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_Name          *string
	clearedFields  map[string]struct{}
	targets        map[int]struct{}
	removedtargets map[int]struct{}
	clearedtargets bool
	tasks          map[int]struct{}
	removedtasks   map[int]struct{}
	clearedtasks   bool
	jobs           map[int]struct{}
	removedjobs    map[int]struct{}
	clearedjobs    bool
	done           bool
	oldValue       func(context.Context) (*Tag, error)
	predicates     []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *TagMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *TagMutation) ResetName() {
	m._Name = nil
}

// AddTargetIDs adds the "targets" edge to the Target entity by ids.
func (m *TagMutation) AddTargetIDs(ids ...int) {
	if m.targets == nil {
		m.targets = make(map[int]struct{})
	}
	for i := range ids {
		m.targets[ids[i]] = struct{}{}
	}
}

// ClearTargets clears the "targets" edge to the Target entity.
func (m *TagMutation) ClearTargets() {
	m.clearedtargets = true
}

// TargetsCleared reports if the "targets" edge to the Target entity was cleared.
func (m *TagMutation) TargetsCleared() bool {
	return m.clearedtargets
}

// RemoveTargetIDs removes the "targets" edge to the Target entity by IDs.
func (m *TagMutation) RemoveTargetIDs(ids ...int) {
	if m.removedtargets == nil {
		m.removedtargets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.targets, ids[i])
		m.removedtargets[ids[i]] = struct{}{}
	}
}

// RemovedTargets returns the removed IDs of the "targets" edge to the Target entity.
func (m *TagMutation) RemovedTargetsIDs() (ids []int) {
	for id := range m.removedtargets {
		ids = append(ids, id)
	}
	return
}

// TargetsIDs returns the "targets" edge IDs in the mutation.
func (m *TagMutation) TargetsIDs() (ids []int) {
	for id := range m.targets {
		ids = append(ids, id)
	}
	return
}

// ResetTargets resets all changes to the "targets" edge.
func (m *TagMutation) ResetTargets() {
	m.targets = nil
	m.clearedtargets = false
	m.removedtargets = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *TagMutation) AddTaskIDs(ids ...int) {
	if m.tasks == nil {
		m.tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *TagMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *TagMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *TagMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *TagMutation) RemovedTasksIDs() (ids []int) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *TagMutation) TasksIDs() (ids []int) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *TagMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddJobIDs adds the "jobs" edge to the Job entity by ids.
func (m *TagMutation) AddJobIDs(ids ...int) {
	if m.jobs == nil {
		m.jobs = make(map[int]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the Job entity.
func (m *TagMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the Job entity was cleared.
func (m *TagMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the Job entity by IDs.
func (m *TagMutation) RemoveJobIDs(ids ...int) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the Job entity.
func (m *TagMutation) RemovedJobsIDs() (ids []int) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *TagMutation) JobsIDs() (ids []int) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *TagMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.targets != nil {
		edges = append(edges, tag.EdgeTargets)
	}
	if m.tasks != nil {
		edges = append(edges, tag.EdgeTasks)
	}
	if m.jobs != nil {
		edges = append(edges, tag.EdgeJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeTargets:
		ids := make([]ent.Value, 0, len(m.targets))
		for id := range m.targets {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtargets != nil {
		edges = append(edges, tag.EdgeTargets)
	}
	if m.removedtasks != nil {
		edges = append(edges, tag.EdgeTasks)
	}
	if m.removedjobs != nil {
		edges = append(edges, tag.EdgeJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeTargets:
		ids := make([]ent.Value, 0, len(m.removedtargets))
		for id := range m.removedtargets {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtargets {
		edges = append(edges, tag.EdgeTargets)
	}
	if m.clearedtasks {
		edges = append(edges, tag.EdgeTasks)
	}
	if m.clearedjobs {
		edges = append(edges, tag.EdgeJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeTargets:
		return m.clearedtargets
	case tag.EdgeTasks:
		return m.clearedtasks
	case tag.EdgeJobs:
		return m.clearedjobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeTargets:
		m.ResetTargets()
		return nil
	case tag.EdgeTasks:
		m.ResetTasks()
		return nil
	case tag.EdgeJobs:
		m.ResetJobs()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TargetMutation represents an operation that mutates the Target nodes in the graph.
type TargetMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_Name              *string
	_OS                *target.OS
	_PrimaryIP         *string
	_MachineUUID       *string
	_PublicIP          *string
	_PrimaryMAC        *string
	_Hostname          *string
	_LastSeen          *time.Time
	clearedFields      map[string]struct{}
	tasks              map[int]struct{}
	removedtasks       map[int]struct{}
	clearedtasks       bool
	tags               map[int]struct{}
	removedtags        map[int]struct{}
	clearedtags        bool
	credentials        map[int]struct{}
	removedcredentials map[int]struct{}
	clearedcredentials bool
	done               bool
	oldValue           func(context.Context) (*Target, error)
	predicates         []predicate.Target
}

var _ ent.Mutation = (*TargetMutation)(nil)

// targetOption allows management of the mutation configuration using functional options.
type targetOption func(*TargetMutation)

// newTargetMutation creates new mutation for the Target entity.
func newTargetMutation(c config, op Op, opts ...targetOption) *TargetMutation {
	m := &TargetMutation{
		config:        c,
		op:            op,
		typ:           TypeTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTargetID sets the ID field of the mutation.
func withTargetID(id int) targetOption {
	return func(m *TargetMutation) {
		var (
			err   error
			once  sync.Once
			value *Target
		)
		m.oldValue = func(ctx context.Context) (*Target, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Target.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTarget sets the old Target of the mutation.
func withTarget(node *Target) targetOption {
	return func(m *TargetMutation) {
		m.oldValue = func(context.Context) (*Target, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TargetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TargetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Target.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *TargetMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *TargetMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *TargetMutation) ResetName() {
	m._Name = nil
}

// SetOS sets the "OS" field.
func (m *TargetMutation) SetOS(t target.OS) {
	m._OS = &t
}

// OS returns the value of the "OS" field in the mutation.
func (m *TargetMutation) OS() (r target.OS, exists bool) {
	v := m._OS
	if v == nil {
		return
	}
	return *v, true
}

// OldOS returns the old "OS" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldOS(ctx context.Context) (v target.OS, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOS: %w", err)
	}
	return oldValue.OS, nil
}

// ResetOS resets all changes to the "OS" field.
func (m *TargetMutation) ResetOS() {
	m._OS = nil
}

// SetPrimaryIP sets the "PrimaryIP" field.
func (m *TargetMutation) SetPrimaryIP(s string) {
	m._PrimaryIP = &s
}

// PrimaryIP returns the value of the "PrimaryIP" field in the mutation.
func (m *TargetMutation) PrimaryIP() (r string, exists bool) {
	v := m._PrimaryIP
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryIP returns the old "PrimaryIP" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldPrimaryIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryIP: %w", err)
	}
	return oldValue.PrimaryIP, nil
}

// ResetPrimaryIP resets all changes to the "PrimaryIP" field.
func (m *TargetMutation) ResetPrimaryIP() {
	m._PrimaryIP = nil
}

// SetMachineUUID sets the "MachineUUID" field.
func (m *TargetMutation) SetMachineUUID(s string) {
	m._MachineUUID = &s
}

// MachineUUID returns the value of the "MachineUUID" field in the mutation.
func (m *TargetMutation) MachineUUID() (r string, exists bool) {
	v := m._MachineUUID
	if v == nil {
		return
	}
	return *v, true
}

// OldMachineUUID returns the old "MachineUUID" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldMachineUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMachineUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMachineUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMachineUUID: %w", err)
	}
	return oldValue.MachineUUID, nil
}

// ClearMachineUUID clears the value of the "MachineUUID" field.
func (m *TargetMutation) ClearMachineUUID() {
	m._MachineUUID = nil
	m.clearedFields[target.FieldMachineUUID] = struct{}{}
}

// MachineUUIDCleared returns if the "MachineUUID" field was cleared in this mutation.
func (m *TargetMutation) MachineUUIDCleared() bool {
	_, ok := m.clearedFields[target.FieldMachineUUID]
	return ok
}

// ResetMachineUUID resets all changes to the "MachineUUID" field.
func (m *TargetMutation) ResetMachineUUID() {
	m._MachineUUID = nil
	delete(m.clearedFields, target.FieldMachineUUID)
}

// SetPublicIP sets the "PublicIP" field.
func (m *TargetMutation) SetPublicIP(s string) {
	m._PublicIP = &s
}

// PublicIP returns the value of the "PublicIP" field in the mutation.
func (m *TargetMutation) PublicIP() (r string, exists bool) {
	v := m._PublicIP
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicIP returns the old "PublicIP" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldPublicIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicIP: %w", err)
	}
	return oldValue.PublicIP, nil
}

// ClearPublicIP clears the value of the "PublicIP" field.
func (m *TargetMutation) ClearPublicIP() {
	m._PublicIP = nil
	m.clearedFields[target.FieldPublicIP] = struct{}{}
}

// PublicIPCleared returns if the "PublicIP" field was cleared in this mutation.
func (m *TargetMutation) PublicIPCleared() bool {
	_, ok := m.clearedFields[target.FieldPublicIP]
	return ok
}

// ResetPublicIP resets all changes to the "PublicIP" field.
func (m *TargetMutation) ResetPublicIP() {
	m._PublicIP = nil
	delete(m.clearedFields, target.FieldPublicIP)
}

// SetPrimaryMAC sets the "PrimaryMAC" field.
func (m *TargetMutation) SetPrimaryMAC(s string) {
	m._PrimaryMAC = &s
}

// PrimaryMAC returns the value of the "PrimaryMAC" field in the mutation.
func (m *TargetMutation) PrimaryMAC() (r string, exists bool) {
	v := m._PrimaryMAC
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryMAC returns the old "PrimaryMAC" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldPrimaryMAC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryMAC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryMAC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryMAC: %w", err)
	}
	return oldValue.PrimaryMAC, nil
}

// ClearPrimaryMAC clears the value of the "PrimaryMAC" field.
func (m *TargetMutation) ClearPrimaryMAC() {
	m._PrimaryMAC = nil
	m.clearedFields[target.FieldPrimaryMAC] = struct{}{}
}

// PrimaryMACCleared returns if the "PrimaryMAC" field was cleared in this mutation.
func (m *TargetMutation) PrimaryMACCleared() bool {
	_, ok := m.clearedFields[target.FieldPrimaryMAC]
	return ok
}

// ResetPrimaryMAC resets all changes to the "PrimaryMAC" field.
func (m *TargetMutation) ResetPrimaryMAC() {
	m._PrimaryMAC = nil
	delete(m.clearedFields, target.FieldPrimaryMAC)
}

// SetHostname sets the "Hostname" field.
func (m *TargetMutation) SetHostname(s string) {
	m._Hostname = &s
}

// Hostname returns the value of the "Hostname" field in the mutation.
func (m *TargetMutation) Hostname() (r string, exists bool) {
	v := m._Hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "Hostname" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ClearHostname clears the value of the "Hostname" field.
func (m *TargetMutation) ClearHostname() {
	m._Hostname = nil
	m.clearedFields[target.FieldHostname] = struct{}{}
}

// HostnameCleared returns if the "Hostname" field was cleared in this mutation.
func (m *TargetMutation) HostnameCleared() bool {
	_, ok := m.clearedFields[target.FieldHostname]
	return ok
}

// ResetHostname resets all changes to the "Hostname" field.
func (m *TargetMutation) ResetHostname() {
	m._Hostname = nil
	delete(m.clearedFields, target.FieldHostname)
}

// SetLastSeen sets the "LastSeen" field.
func (m *TargetMutation) SetLastSeen(t time.Time) {
	m._LastSeen = &t
}

// LastSeen returns the value of the "LastSeen" field in the mutation.
func (m *TargetMutation) LastSeen() (r time.Time, exists bool) {
	v := m._LastSeen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "LastSeen" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldLastSeen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ClearLastSeen clears the value of the "LastSeen" field.
func (m *TargetMutation) ClearLastSeen() {
	m._LastSeen = nil
	m.clearedFields[target.FieldLastSeen] = struct{}{}
}

// LastSeenCleared returns if the "LastSeen" field was cleared in this mutation.
func (m *TargetMutation) LastSeenCleared() bool {
	_, ok := m.clearedFields[target.FieldLastSeen]
	return ok
}

// ResetLastSeen resets all changes to the "LastSeen" field.
func (m *TargetMutation) ResetLastSeen() {
	m._LastSeen = nil
	delete(m.clearedFields, target.FieldLastSeen)
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *TargetMutation) AddTaskIDs(ids ...int) {
	if m.tasks == nil {
		m.tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *TargetMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *TargetMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *TargetMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *TargetMutation) RemovedTasksIDs() (ids []int) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *TargetMutation) TasksIDs() (ids []int) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *TargetMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *TargetMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *TargetMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *TargetMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *TargetMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *TargetMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *TargetMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *TargetMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddCredentialIDs adds the "credentials" edge to the Credential entity by ids.
func (m *TargetMutation) AddCredentialIDs(ids ...int) {
	if m.credentials == nil {
		m.credentials = make(map[int]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credential entity.
func (m *TargetMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credential entity was cleared.
func (m *TargetMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credential entity by IDs.
func (m *TargetMutation) RemoveCredentialIDs(ids ...int) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credential entity.
func (m *TargetMutation) RemovedCredentialsIDs() (ids []int) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *TargetMutation) CredentialsIDs() (ids []int) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *TargetMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// Where appends a list predicates to the TargetMutation builder.
func (m *TargetMutation) Where(ps ...predicate.Target) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TargetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Target).
func (m *TargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TargetMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._Name != nil {
		fields = append(fields, target.FieldName)
	}
	if m._OS != nil {
		fields = append(fields, target.FieldOS)
	}
	if m._PrimaryIP != nil {
		fields = append(fields, target.FieldPrimaryIP)
	}
	if m._MachineUUID != nil {
		fields = append(fields, target.FieldMachineUUID)
	}
	if m._PublicIP != nil {
		fields = append(fields, target.FieldPublicIP)
	}
	if m._PrimaryMAC != nil {
		fields = append(fields, target.FieldPrimaryMAC)
	}
	if m._Hostname != nil {
		fields = append(fields, target.FieldHostname)
	}
	if m._LastSeen != nil {
		fields = append(fields, target.FieldLastSeen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case target.FieldName:
		return m.Name()
	case target.FieldOS:
		return m.OS()
	case target.FieldPrimaryIP:
		return m.PrimaryIP()
	case target.FieldMachineUUID:
		return m.MachineUUID()
	case target.FieldPublicIP:
		return m.PublicIP()
	case target.FieldPrimaryMAC:
		return m.PrimaryMAC()
	case target.FieldHostname:
		return m.Hostname()
	case target.FieldLastSeen:
		return m.LastSeen()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case target.FieldName:
		return m.OldName(ctx)
	case target.FieldOS:
		return m.OldOS(ctx)
	case target.FieldPrimaryIP:
		return m.OldPrimaryIP(ctx)
	case target.FieldMachineUUID:
		return m.OldMachineUUID(ctx)
	case target.FieldPublicIP:
		return m.OldPublicIP(ctx)
	case target.FieldPrimaryMAC:
		return m.OldPrimaryMAC(ctx)
	case target.FieldHostname:
		return m.OldHostname(ctx)
	case target.FieldLastSeen:
		return m.OldLastSeen(ctx)
	}
	return nil, fmt.Errorf("unknown Target field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case target.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case target.FieldOS:
		v, ok := value.(target.OS)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOS(v)
		return nil
	case target.FieldPrimaryIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryIP(v)
		return nil
	case target.FieldMachineUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMachineUUID(v)
		return nil
	case target.FieldPublicIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicIP(v)
		return nil
	case target.FieldPrimaryMAC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryMAC(v)
		return nil
	case target.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case target.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	}
	return fmt.Errorf("unknown Target field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TargetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TargetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Target numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TargetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(target.FieldMachineUUID) {
		fields = append(fields, target.FieldMachineUUID)
	}
	if m.FieldCleared(target.FieldPublicIP) {
		fields = append(fields, target.FieldPublicIP)
	}
	if m.FieldCleared(target.FieldPrimaryMAC) {
		fields = append(fields, target.FieldPrimaryMAC)
	}
	if m.FieldCleared(target.FieldHostname) {
		fields = append(fields, target.FieldHostname)
	}
	if m.FieldCleared(target.FieldLastSeen) {
		fields = append(fields, target.FieldLastSeen)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TargetMutation) ClearField(name string) error {
	switch name {
	case target.FieldMachineUUID:
		m.ClearMachineUUID()
		return nil
	case target.FieldPublicIP:
		m.ClearPublicIP()
		return nil
	case target.FieldPrimaryMAC:
		m.ClearPrimaryMAC()
		return nil
	case target.FieldHostname:
		m.ClearHostname()
		return nil
	case target.FieldLastSeen:
		m.ClearLastSeen()
		return nil
	}
	return fmt.Errorf("unknown Target nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TargetMutation) ResetField(name string) error {
	switch name {
	case target.FieldName:
		m.ResetName()
		return nil
	case target.FieldOS:
		m.ResetOS()
		return nil
	case target.FieldPrimaryIP:
		m.ResetPrimaryIP()
		return nil
	case target.FieldMachineUUID:
		m.ResetMachineUUID()
		return nil
	case target.FieldPublicIP:
		m.ResetPublicIP()
		return nil
	case target.FieldPrimaryMAC:
		m.ResetPrimaryMAC()
		return nil
	case target.FieldHostname:
		m.ResetHostname()
		return nil
	case target.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	}
	return fmt.Errorf("unknown Target field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tasks != nil {
		edges = append(edges, target.EdgeTasks)
	}
	if m.tags != nil {
		edges = append(edges, target.EdgeTags)
	}
	if m.credentials != nil {
		edges = append(edges, target.EdgeCredentials)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case target.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtasks != nil {
		edges = append(edges, target.EdgeTasks)
	}
	if m.removedtags != nil {
		edges = append(edges, target.EdgeTags)
	}
	if m.removedcredentials != nil {
		edges = append(edges, target.EdgeCredentials)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TargetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case target.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtasks {
		edges = append(edges, target.EdgeTasks)
	}
	if m.clearedtags {
		edges = append(edges, target.EdgeTags)
	}
	if m.clearedcredentials {
		edges = append(edges, target.EdgeCredentials)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TargetMutation) EdgeCleared(name string) bool {
	switch name {
	case target.EdgeTasks:
		return m.clearedtasks
	case target.EdgeTags:
		return m.clearedtags
	case target.EdgeCredentials:
		return m.clearedcredentials
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TargetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Target unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TargetMutation) ResetEdge(name string) error {
	switch name {
	case target.EdgeTasks:
		m.ResetTasks()
		return nil
	case target.EdgeTags:
		m.ResetTags()
		return nil
	case target.EdgeCredentials:
		m.ResetCredentials()
		return nil
	}
	return fmt.Errorf("unknown Target edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_QueueTime       *time.Time
	_LastChangedTime *time.Time
	_ClaimTime       *time.Time
	_ExecStartTime   *time.Time
	_ExecStopTime    *time.Time
	_Content         *string
	_Output          *string
	_Error           *string
	_SessionID       *string
	clearedFields    map[string]struct{}
	tags             map[int]struct{}
	removedtags      map[int]struct{}
	clearedtags      bool
	job              *int
	clearedjob       bool
	target           *int
	clearedtarget    bool
	done             bool
	oldValue         func(context.Context) (*Task, error)
	predicates       []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQueueTime sets the "QueueTime" field.
func (m *TaskMutation) SetQueueTime(t time.Time) {
	m._QueueTime = &t
}

// QueueTime returns the value of the "QueueTime" field in the mutation.
func (m *TaskMutation) QueueTime() (r time.Time, exists bool) {
	v := m._QueueTime
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueTime returns the old "QueueTime" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldQueueTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueueTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueueTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueTime: %w", err)
	}
	return oldValue.QueueTime, nil
}

// ResetQueueTime resets all changes to the "QueueTime" field.
func (m *TaskMutation) ResetQueueTime() {
	m._QueueTime = nil
}

// SetLastChangedTime sets the "LastChangedTime" field.
func (m *TaskMutation) SetLastChangedTime(t time.Time) {
	m._LastChangedTime = &t
}

// LastChangedTime returns the value of the "LastChangedTime" field in the mutation.
func (m *TaskMutation) LastChangedTime() (r time.Time, exists bool) {
	v := m._LastChangedTime
	if v == nil {
		return
	}
	return *v, true
}

// OldLastChangedTime returns the old "LastChangedTime" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLastChangedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastChangedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastChangedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastChangedTime: %w", err)
	}
	return oldValue.LastChangedTime, nil
}

// ResetLastChangedTime resets all changes to the "LastChangedTime" field.
func (m *TaskMutation) ResetLastChangedTime() {
	m._LastChangedTime = nil
}

// SetClaimTime sets the "ClaimTime" field.
func (m *TaskMutation) SetClaimTime(t time.Time) {
	m._ClaimTime = &t
}

// ClaimTime returns the value of the "ClaimTime" field in the mutation.
func (m *TaskMutation) ClaimTime() (r time.Time, exists bool) {
	v := m._ClaimTime
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimTime returns the old "ClaimTime" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldClaimTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimTime: %w", err)
	}
	return oldValue.ClaimTime, nil
}

// ClearClaimTime clears the value of the "ClaimTime" field.
func (m *TaskMutation) ClearClaimTime() {
	m._ClaimTime = nil
	m.clearedFields[task.FieldClaimTime] = struct{}{}
}

// ClaimTimeCleared returns if the "ClaimTime" field was cleared in this mutation.
func (m *TaskMutation) ClaimTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldClaimTime]
	return ok
}

// ResetClaimTime resets all changes to the "ClaimTime" field.
func (m *TaskMutation) ResetClaimTime() {
	m._ClaimTime = nil
	delete(m.clearedFields, task.FieldClaimTime)
}

// SetExecStartTime sets the "ExecStartTime" field.
func (m *TaskMutation) SetExecStartTime(t time.Time) {
	m._ExecStartTime = &t
}

// ExecStartTime returns the value of the "ExecStartTime" field in the mutation.
func (m *TaskMutation) ExecStartTime() (r time.Time, exists bool) {
	v := m._ExecStartTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExecStartTime returns the old "ExecStartTime" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldExecStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecStartTime: %w", err)
	}
	return oldValue.ExecStartTime, nil
}

// ClearExecStartTime clears the value of the "ExecStartTime" field.
func (m *TaskMutation) ClearExecStartTime() {
	m._ExecStartTime = nil
	m.clearedFields[task.FieldExecStartTime] = struct{}{}
}

// ExecStartTimeCleared returns if the "ExecStartTime" field was cleared in this mutation.
func (m *TaskMutation) ExecStartTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldExecStartTime]
	return ok
}

// ResetExecStartTime resets all changes to the "ExecStartTime" field.
func (m *TaskMutation) ResetExecStartTime() {
	m._ExecStartTime = nil
	delete(m.clearedFields, task.FieldExecStartTime)
}

// SetExecStopTime sets the "ExecStopTime" field.
func (m *TaskMutation) SetExecStopTime(t time.Time) {
	m._ExecStopTime = &t
}

// ExecStopTime returns the value of the "ExecStopTime" field in the mutation.
func (m *TaskMutation) ExecStopTime() (r time.Time, exists bool) {
	v := m._ExecStopTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExecStopTime returns the old "ExecStopTime" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldExecStopTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecStopTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecStopTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecStopTime: %w", err)
	}
	return oldValue.ExecStopTime, nil
}

// ClearExecStopTime clears the value of the "ExecStopTime" field.
func (m *TaskMutation) ClearExecStopTime() {
	m._ExecStopTime = nil
	m.clearedFields[task.FieldExecStopTime] = struct{}{}
}

// ExecStopTimeCleared returns if the "ExecStopTime" field was cleared in this mutation.
func (m *TaskMutation) ExecStopTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldExecStopTime]
	return ok
}

// ResetExecStopTime resets all changes to the "ExecStopTime" field.
func (m *TaskMutation) ResetExecStopTime() {
	m._ExecStopTime = nil
	delete(m.clearedFields, task.FieldExecStopTime)
}

// SetContent sets the "Content" field.
func (m *TaskMutation) SetContent(s string) {
	m._Content = &s
}

// Content returns the value of the "Content" field in the mutation.
func (m *TaskMutation) Content() (r string, exists bool) {
	v := m._Content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "Content" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "Content" field.
func (m *TaskMutation) ResetContent() {
	m._Content = nil
}

// SetOutput sets the "Output" field.
func (m *TaskMutation) SetOutput(s string) {
	m._Output = &s
}

// Output returns the value of the "Output" field in the mutation.
func (m *TaskMutation) Output() (r string, exists bool) {
	v := m._Output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "Output" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "Output" field.
func (m *TaskMutation) ClearOutput() {
	m._Output = nil
	m.clearedFields[task.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "Output" field was cleared in this mutation.
func (m *TaskMutation) OutputCleared() bool {
	_, ok := m.clearedFields[task.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "Output" field.
func (m *TaskMutation) ResetOutput() {
	m._Output = nil
	delete(m.clearedFields, task.FieldOutput)
}

// SetError sets the "Error" field.
func (m *TaskMutation) SetError(s string) {
	m._Error = &s
}

// Error returns the value of the "Error" field in the mutation.
func (m *TaskMutation) Error() (r string, exists bool) {
	v := m._Error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "Error" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "Error" field.
func (m *TaskMutation) ClearError() {
	m._Error = nil
	m.clearedFields[task.FieldError] = struct{}{}
}

// ErrorCleared returns if the "Error" field was cleared in this mutation.
func (m *TaskMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[task.FieldError]
	return ok
}

// ResetError resets all changes to the "Error" field.
func (m *TaskMutation) ResetError() {
	m._Error = nil
	delete(m.clearedFields, task.FieldError)
}

// SetSessionID sets the "SessionID" field.
func (m *TaskMutation) SetSessionID(s string) {
	m._SessionID = &s
}

// SessionID returns the value of the "SessionID" field in the mutation.
func (m *TaskMutation) SessionID() (r string, exists bool) {
	v := m._SessionID
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "SessionID" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ClearSessionID clears the value of the "SessionID" field.
func (m *TaskMutation) ClearSessionID() {
	m._SessionID = nil
	m.clearedFields[task.FieldSessionID] = struct{}{}
}

// SessionIDCleared returns if the "SessionID" field was cleared in this mutation.
func (m *TaskMutation) SessionIDCleared() bool {
	_, ok := m.clearedFields[task.FieldSessionID]
	return ok
}

// ResetSessionID resets all changes to the "SessionID" field.
func (m *TaskMutation) ResetSessionID() {
	m._SessionID = nil
	delete(m.clearedFields, task.FieldSessionID)
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *TaskMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *TaskMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *TaskMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *TaskMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *TaskMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *TaskMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *TaskMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *TaskMutation) SetJobID(id int) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *TaskMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *TaskMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *TaskMutation) JobID() (id int, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) JobIDs() (ids []int) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *TaskMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// SetTargetID sets the "target" edge to the Target entity by id.
func (m *TaskMutation) SetTargetID(id int) {
	m.target = &id
}

// ClearTarget clears the "target" edge to the Target entity.
func (m *TaskMutation) ClearTarget() {
	m.clearedtarget = true
}

// TargetCleared reports if the "target" edge to the Target entity was cleared.
func (m *TaskMutation) TargetCleared() bool {
	return m.clearedtarget
}

// TargetID returns the "target" edge ID in the mutation.
func (m *TaskMutation) TargetID() (id int, exists bool) {
	if m.target != nil {
		return *m.target, true
	}
	return
}

// TargetIDs returns the "target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) TargetIDs() (ids []int) {
	if id := m.target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTarget resets all changes to the "target" edge.
func (m *TaskMutation) ResetTarget() {
	m.target = nil
	m.clearedtarget = false
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._QueueTime != nil {
		fields = append(fields, task.FieldQueueTime)
	}
	if m._LastChangedTime != nil {
		fields = append(fields, task.FieldLastChangedTime)
	}
	if m._ClaimTime != nil {
		fields = append(fields, task.FieldClaimTime)
	}
	if m._ExecStartTime != nil {
		fields = append(fields, task.FieldExecStartTime)
	}
	if m._ExecStopTime != nil {
		fields = append(fields, task.FieldExecStopTime)
	}
	if m._Content != nil {
		fields = append(fields, task.FieldContent)
	}
	if m._Output != nil {
		fields = append(fields, task.FieldOutput)
	}
	if m._Error != nil {
		fields = append(fields, task.FieldError)
	}
	if m._SessionID != nil {
		fields = append(fields, task.FieldSessionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldQueueTime:
		return m.QueueTime()
	case task.FieldLastChangedTime:
		return m.LastChangedTime()
	case task.FieldClaimTime:
		return m.ClaimTime()
	case task.FieldExecStartTime:
		return m.ExecStartTime()
	case task.FieldExecStopTime:
		return m.ExecStopTime()
	case task.FieldContent:
		return m.Content()
	case task.FieldOutput:
		return m.Output()
	case task.FieldError:
		return m.Error()
	case task.FieldSessionID:
		return m.SessionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldQueueTime:
		return m.OldQueueTime(ctx)
	case task.FieldLastChangedTime:
		return m.OldLastChangedTime(ctx)
	case task.FieldClaimTime:
		return m.OldClaimTime(ctx)
	case task.FieldExecStartTime:
		return m.OldExecStartTime(ctx)
	case task.FieldExecStopTime:
		return m.OldExecStopTime(ctx)
	case task.FieldContent:
		return m.OldContent(ctx)
	case task.FieldOutput:
		return m.OldOutput(ctx)
	case task.FieldError:
		return m.OldError(ctx)
	case task.FieldSessionID:
		return m.OldSessionID(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldQueueTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueTime(v)
		return nil
	case task.FieldLastChangedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastChangedTime(v)
		return nil
	case task.FieldClaimTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimTime(v)
		return nil
	case task.FieldExecStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecStartTime(v)
		return nil
	case task.FieldExecStopTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecStopTime(v)
		return nil
	case task.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case task.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case task.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case task.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldClaimTime) {
		fields = append(fields, task.FieldClaimTime)
	}
	if m.FieldCleared(task.FieldExecStartTime) {
		fields = append(fields, task.FieldExecStartTime)
	}
	if m.FieldCleared(task.FieldExecStopTime) {
		fields = append(fields, task.FieldExecStopTime)
	}
	if m.FieldCleared(task.FieldOutput) {
		fields = append(fields, task.FieldOutput)
	}
	if m.FieldCleared(task.FieldError) {
		fields = append(fields, task.FieldError)
	}
	if m.FieldCleared(task.FieldSessionID) {
		fields = append(fields, task.FieldSessionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldClaimTime:
		m.ClearClaimTime()
		return nil
	case task.FieldExecStartTime:
		m.ClearExecStartTime()
		return nil
	case task.FieldExecStopTime:
		m.ClearExecStopTime()
		return nil
	case task.FieldOutput:
		m.ClearOutput()
		return nil
	case task.FieldError:
		m.ClearError()
		return nil
	case task.FieldSessionID:
		m.ClearSessionID()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldQueueTime:
		m.ResetQueueTime()
		return nil
	case task.FieldLastChangedTime:
		m.ResetLastChangedTime()
		return nil
	case task.FieldClaimTime:
		m.ResetClaimTime()
		return nil
	case task.FieldExecStartTime:
		m.ResetExecStartTime()
		return nil
	case task.FieldExecStopTime:
		m.ResetExecStopTime()
		return nil
	case task.FieldContent:
		m.ResetContent()
		return nil
	case task.FieldOutput:
		m.ResetOutput()
		return nil
	case task.FieldError:
		m.ResetError()
		return nil
	case task.FieldSessionID:
		m.ResetSessionID()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tags != nil {
		edges = append(edges, task.EdgeTags)
	}
	if m.job != nil {
		edges = append(edges, task.EdgeJob)
	}
	if m.target != nil {
		edges = append(edges, task.EdgeTarget)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeTarget:
		if id := m.target; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtags != nil {
		edges = append(edges, task.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtags {
		edges = append(edges, task.EdgeTags)
	}
	if m.clearedjob {
		edges = append(edges, task.EdgeJob)
	}
	if m.clearedtarget {
		edges = append(edges, task.EdgeTarget)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeTags:
		return m.clearedtags
	case task.EdgeJob:
		return m.clearedjob
	case task.EdgeTarget:
		return m.clearedtarget
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeJob:
		m.ClearJob()
		return nil
	case task.EdgeTarget:
		m.ClearTarget()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeTags:
		m.ResetTags()
		return nil
	case task.EdgeJob:
		m.ResetJob()
		return nil
	case task.EdgeTarget:
		m.ResetTarget()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_OAuthID      *string
	_PhotoURL     *string
	_SessionToken *string
	_IsActivated  *bool
	_IsAdmin      *bool
	clearedFields map[string]struct{}
	jobs          map[int]struct{}
	removedjobs   map[int]struct{}
	clearedjobs   bool
	events        map[int]struct{}
	removedevents map[int]struct{}
	clearedevents bool
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *UserMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *UserMutation) ResetName() {
	m._Name = nil
}

// SetOAuthID sets the "OAuthID" field.
func (m *UserMutation) SetOAuthID(s string) {
	m._OAuthID = &s
}

// OAuthID returns the value of the "OAuthID" field in the mutation.
func (m *UserMutation) OAuthID() (r string, exists bool) {
	v := m._OAuthID
	if v == nil {
		return
	}
	return *v, true
}

// OldOAuthID returns the old "OAuthID" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOAuthID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOAuthID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOAuthID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOAuthID: %w", err)
	}
	return oldValue.OAuthID, nil
}

// ResetOAuthID resets all changes to the "OAuthID" field.
func (m *UserMutation) ResetOAuthID() {
	m._OAuthID = nil
}

// SetPhotoURL sets the "PhotoURL" field.
func (m *UserMutation) SetPhotoURL(s string) {
	m._PhotoURL = &s
}

// PhotoURL returns the value of the "PhotoURL" field in the mutation.
func (m *UserMutation) PhotoURL() (r string, exists bool) {
	v := m._PhotoURL
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoURL returns the old "PhotoURL" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhotoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoURL: %w", err)
	}
	return oldValue.PhotoURL, nil
}

// ResetPhotoURL resets all changes to the "PhotoURL" field.
func (m *UserMutation) ResetPhotoURL() {
	m._PhotoURL = nil
}

// SetSessionToken sets the "SessionToken" field.
func (m *UserMutation) SetSessionToken(s string) {
	m._SessionToken = &s
}

// SessionToken returns the value of the "SessionToken" field in the mutation.
func (m *UserMutation) SessionToken() (r string, exists bool) {
	v := m._SessionToken
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionToken returns the old "SessionToken" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSessionToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionToken: %w", err)
	}
	return oldValue.SessionToken, nil
}

// ClearSessionToken clears the value of the "SessionToken" field.
func (m *UserMutation) ClearSessionToken() {
	m._SessionToken = nil
	m.clearedFields[user.FieldSessionToken] = struct{}{}
}

// SessionTokenCleared returns if the "SessionToken" field was cleared in this mutation.
func (m *UserMutation) SessionTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldSessionToken]
	return ok
}

// ResetSessionToken resets all changes to the "SessionToken" field.
func (m *UserMutation) ResetSessionToken() {
	m._SessionToken = nil
	delete(m.clearedFields, user.FieldSessionToken)
}

// SetIsActivated sets the "IsActivated" field.
func (m *UserMutation) SetIsActivated(b bool) {
	m._IsActivated = &b
}

// IsActivated returns the value of the "IsActivated" field in the mutation.
func (m *UserMutation) IsActivated() (r bool, exists bool) {
	v := m._IsActivated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActivated returns the old "IsActivated" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActivated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActivated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActivated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActivated: %w", err)
	}
	return oldValue.IsActivated, nil
}

// ResetIsActivated resets all changes to the "IsActivated" field.
func (m *UserMutation) ResetIsActivated() {
	m._IsActivated = nil
}

// SetIsAdmin sets the "IsAdmin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m._IsAdmin = &b
}

// IsAdmin returns the value of the "IsAdmin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m._IsAdmin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "IsAdmin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "IsAdmin" field.
func (m *UserMutation) ResetIsAdmin() {
	m._IsAdmin = nil
}

// AddJobIDs adds the "jobs" edge to the Job entity by ids.
func (m *UserMutation) AddJobIDs(ids ...int) {
	if m.jobs == nil {
		m.jobs = make(map[int]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the Job entity.
func (m *UserMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the Job entity was cleared.
func (m *UserMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the Job entity by IDs.
func (m *UserMutation) RemoveJobIDs(ids ...int) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the Job entity.
func (m *UserMutation) RemovedJobsIDs() (ids []int) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *UserMutation) JobsIDs() (ids []int) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *UserMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *UserMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *UserMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *UserMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *UserMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *UserMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *UserMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *UserMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._Name != nil {
		fields = append(fields, user.FieldName)
	}
	if m._OAuthID != nil {
		fields = append(fields, user.FieldOAuthID)
	}
	if m._PhotoURL != nil {
		fields = append(fields, user.FieldPhotoURL)
	}
	if m._SessionToken != nil {
		fields = append(fields, user.FieldSessionToken)
	}
	if m._IsActivated != nil {
		fields = append(fields, user.FieldIsActivated)
	}
	if m._IsAdmin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldOAuthID:
		return m.OAuthID()
	case user.FieldPhotoURL:
		return m.PhotoURL()
	case user.FieldSessionToken:
		return m.SessionToken()
	case user.FieldIsActivated:
		return m.IsActivated()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldOAuthID:
		return m.OldOAuthID(ctx)
	case user.FieldPhotoURL:
		return m.OldPhotoURL(ctx)
	case user.FieldSessionToken:
		return m.OldSessionToken(ctx)
	case user.FieldIsActivated:
		return m.OldIsActivated(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldOAuthID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOAuthID(v)
		return nil
	case user.FieldPhotoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoURL(v)
		return nil
	case user.FieldSessionToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionToken(v)
		return nil
	case user.FieldIsActivated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActivated(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldSessionToken) {
		fields = append(fields, user.FieldSessionToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldSessionToken:
		m.ClearSessionToken()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldOAuthID:
		m.ResetOAuthID()
		return nil
	case user.FieldPhotoURL:
		m.ResetPhotoURL()
		return nil
	case user.FieldSessionToken:
		m.ResetSessionToken()
		return nil
	case user.FieldIsActivated:
		m.ResetIsActivated()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.jobs != nil {
		edges = append(edges, user.EdgeJobs)
	}
	if m.events != nil {
		edges = append(edges, user.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedjobs != nil {
		edges = append(edges, user.EdgeJobs)
	}
	if m.removedevents != nil {
		edges = append(edges, user.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedjobs {
		edges = append(edges, user.EdgeJobs)
	}
	if m.clearedevents {
		edges = append(edges, user.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeJobs:
		return m.clearedjobs
	case user.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeJobs:
		m.ResetJobs()
		return nil
	case user.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
