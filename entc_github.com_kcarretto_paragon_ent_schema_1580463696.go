// Code generated by 'entc generate'. DO NOT EDIT.
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/facebookincubator/ent"
	"github.com/facebookincubator/ent/schema/edge"
	"github.com/facebookincubator/ent/schema/field"
	"os"
	"reflect"

	"github.com/kcarretto/paragon/ent/schema"
)

var schemas = []ent.Interface{
	schema.Credential{},
	schema.Event{},
	schema.File{},
	schema.Job{},
	schema.Link{},
	schema.Service{},
	schema.Tag{},
	schema.Target{},
	schema.Task{},
	schema.User{},
}

func main() {
	var lines [][]byte
	for _, schema := range schemas {
		b, err := MarshalSchema(schema)
		if err != nil {
			fail(err)
		}
		lines = append(lines, b)
	}
	os.Stdout.Write(bytes.Join(lines, []byte("\n")))
}

func fail(err error) {
	os.Stderr.WriteString(err.Error())
	os.Exit(1)
}

type Schema struct {
	Name    string     `json:"name,omitempty"`
	Config  ent.Config `json:"config,omitempty"`
	Edges   []*Edge    `json:"edges,omitempty"`
	Fields  []*Field   `json:"fields,omitempty"`
	Indexes []*Index   `json:"indexes,omitempty"`
}
type Position struct {
	Index      int
	MixedIn    bool
	MixinIndex int
}
type Field struct {
	Name          string          `json:"name,omitempty"`
	Info          *field.TypeInfo `json:"type,omitempty"`
	Tag           string          `json:"tag,omitempty"`
	Size          *int64          `json:"size,omitempty"`
	Enums         []string        `json:"enums,omitempty"`
	Unique        bool            `json:"unique,omitempty"`
	Nillable      bool            `json:"nillable,omitempty"`
	Optional      bool            `json:"optional,omitempty"`
	Default       bool            `json:"default,omitempty"`
	DefaultValue  interface{}     `json:"default_value,omitempty"`
	UpdateDefault bool            `json:"update_default,omitempty"`
	Immutable     bool            `json:"immutable,omitempty"`
	Validators    int             `json:"validators,omitempty"`
	StorageKey    string          `json:"storage_key,omitempty"`
	Position      *Position       `json:"position,omitempty"`
	Sensitive     bool            `json:"sensitive,omitempty"`
}
type Edge struct {
	Name     string `json:"name,omitempty"`
	Type     string `json:"type,omitempty"`
	Tag      string `json:"tag,omitempty"`
	RefName  string `json:"ref_name,omitempty"`
	Ref      *Edge  `json:"ref,omitempty"`
	Unique   bool   `json:"unique,omitempty"`
	Inverse  bool   `json:"inverse,omitempty"`
	Required bool   `json:"required,omitempty"`
}
type Index struct {
	Unique     bool     `json:"unique,omitempty"`
	Edges      []string `json:"edges,omitempty"`
	Fields     []string `json:"fields,omitempty"`
	StorageKey string   `json:"storage_key,omitempty"`
}

func NewEdge(ed *edge.Descriptor) *Edge {
	ne := &Edge{
		Tag:      ed.Tag,
		Type:     ed.Type,
		Name:     ed.Name,
		Unique:   ed.Unique,
		Inverse:  ed.Inverse,
		Required: ed.Required,
		RefName:  ed.RefName,
	}
	if ref := ed.Ref; ref != nil {
		ne.Ref = NewEdge(ref)
	}
	return ne
}
func NewField(fd *field.Descriptor) (*Field, error) {
	sf := &Field{
		Name:          fd.Name,
		Info:          fd.Info,
		Tag:           fd.Tag,
		Enums:         fd.Enums,
		Unique:        fd.Unique,
		Nillable:      fd.Nillable,
		Optional:      fd.Optional,
		Default:       fd.Default != nil,
		UpdateDefault: fd.UpdateDefault != nil,
		Immutable:     fd.Immutable,
		StorageKey:    fd.StorageKey,
		Validators:    len(fd.Validators),
		Sensitive:     fd.Sensitive,
	}
	if sf.Info == nil {
		return nil, fmt.Errorf("missing type info for field %q", sf.Name)
	}
	if size := int64(fd.Size); size != 0 {
		sf.Size = &size
	}

	if _, err := json.Marshal(fd.Default); err == nil {
		sf.DefaultValue = fd.Default
	}
	if fd.Info.Type == field.TypeUUID && fd.Default != nil {
		typ := reflect.TypeOf(fd.Default)
		if typ.Kind() != reflect.Func || typ.NumIn() != 0 || typ.NumOut() != 1 || typ.Out(0).String() != fd.Info.String() {
			return nil, fmt.Errorf("expect type (func() %s) for uuid default value", fd.Info.String())
		}
	}
	return sf, nil
}
func MarshalSchema(schema ent.Interface) (b []byte, err error) {
	s := &Schema{
		Config: schema.Config(),
		Name:   indirect(reflect.TypeOf(schema)).Name(),
	}
	if err := s.loadFields(schema); err != nil {
		return nil, err
	}
	edges, err := safeEdges(schema)
	if err != nil {
		return nil, fmt.Errorf("schema %q: %v", s.Name, err)
	}
	for _, e := range edges {
		s.Edges = append(s.Edges, NewEdge(e.Descriptor()))
	}
	indexes, err := safeIndexes(schema)
	if err != nil {
		return nil, fmt.Errorf("schema %q: %v", s.Name, err)
	}
	for _, idx := range indexes {
		idx := idx.Descriptor()
		s.Indexes = append(s.Indexes, &Index{
			Edges:      idx.Edges,
			Fields:     idx.Fields,
			Unique:     idx.Unique,
			StorageKey: idx.StorageKey,
		})
	}
	return json.Marshal(s)
}
func (s *Schema) loadFields(schema ent.Interface) error {
	mixin, err := safeMixin(schema)
	if err != nil {
		return fmt.Errorf("schema %q: %v", s.Name, err)
	}
	for i, mx := range mixin {
		fields, err := safeFields(mx)
		if err != nil {
			return fmt.Errorf("schema %q: %v", s.Name, err)
		}
		for j, f := range fields {
			sf, err := NewField(f.Descriptor())
			if err != nil {
				return fmt.Errorf("schema %q: %v", s.Name, err)
			}
			sf.Position = &Position{
				Index:      j,
				MixedIn:    true,
				MixinIndex: i,
			}
			s.Fields = append(s.Fields, sf)
		}
	}
	fields, err := safeFields(schema)
	if err != nil {
		return fmt.Errorf("schema %q: %v", s.Name, err)
	}
	for i, f := range fields {
		sf, err := NewField(f.Descriptor())
		if err != nil {
			return fmt.Errorf("schema %q: %v", s.Name, err)
		}
		sf.Position = &Position{Index: i}
		s.Fields = append(s.Fields, sf)
	}
	return nil
}
func safeFields(fd interface{ Fields() []ent.Field }) (fields []ent.Field, err error) {
	defer func() {
		if v := recover(); v != nil {
			err = fmt.Errorf("%T.Fields panics: %v", fd, v)
			fields = nil
		}
	}()
	return fd.Fields(), nil
}
func safeEdges(schema ent.Interface) (edges []ent.Edge, err error) {
	defer func() {
		if v := recover(); v != nil {
			err = fmt.Errorf("schema.Edges panics: %v", v)
			edges = nil
		}
	}()
	return schema.Edges(), nil
}
func safeIndexes(schema ent.Interface) (indexes []ent.Index, err error) {
	defer func() {
		if v := recover(); v != nil {
			err = fmt.Errorf("schema.Indexes panics: %v", v)
			indexes = nil
		}
	}()
	return schema.Indexes(), nil
}
func safeMixin(schema ent.Interface) (mixin []ent.Mixin, err error) {
	defer func() {
		if v := recover(); v != nil {
			err = fmt.Errorf("schema.Mixin panics: %v", v)
			mixin = nil
		}
	}()
	return schema.Mixin(), nil
}
func indirect(t reflect.Type) reflect.Type {
	for t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	return t
}
